// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct BezierCurve {
    float2 pointA;
    float2 pointB;
    float2 controllA;
    float2 controllB;
    float length;
};
RWTexture2D<float4> Result;
int pathSize;
int width;
int height;
RWStructuredBuffer<BezierCurve> curves;
int curvesLength;
float stepSize = 0.1f;

float2 calcPoint(BezierCurve curve, float t){
	t = clamp(t, 0, 1);

	float x = ((1 - t) * (1 - t) * (1 - t)) * curve.pointA.x
           + 3 * ((1 - t) * (1 - t)) * t * curve.pointB.x
           + 3 * (1 - t) * (t * t) * curve.controllA.x
           + (t * t * t) * curve.controllB.x;

	float y = ((1 - t) * (1 - t) * (1 - t)) * curve.pointA.y
		+ 3 * ((1 - t) * (1 - t)) * t * curve.pointB.y
		+ 3 * (1 - t) * (t * t) * curve.controllA.y
		+ (t * t * t) * curve.controllB.y;

	return float2(x,y);
}

float distanceToPoint(float2 a, float2 b){
	return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

float distanceToCurve(Curve curve, float2 pos){
	float t = 0;
	float shortestDistance = distanceToPoint(calcPoint(curve, t), pos);
	for(t = 0; t <= 1; t += stepSize){
		shortestDistance = min(shortestDistance, distanceToPoint(calcPoint(curve, t), pos));
	}
	return shortestDistance;
}



[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float4 color = float4(0,0,0,0);

	float shortestDistnace = 1e10;
	for(int i = 0; i < curvesLenght; i++){
		shortestDistnace = min(shortestDistnace, distanceToCurve(curves[i], id.xy));
	}

	Result[id.xy] = color;
}
